<?php

namespace Modules\CRMCore\app\Models;

use App\Traits\UserActionsTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Modules\CRMCore\app\Traits\HasCRMCode;
use OwenIt\Auditing\Auditable as AuditableTrait;
use OwenIt\Auditing\Contracts\Auditable as AuditableContract;

class Customer extends Model implements AuditableContract
{
    use AuditableTrait, HasCRMCode, HasFactory, SoftDeletes, UserActionsTrait;

    protected $table = 'customers';

    protected $fillable = [
        'contact_id',
        'code',
        'customer_group_id',
        'lifetime_value',
        'first_purchase_date',
        'last_purchase_date',
        'purchase_count',
        'average_order_value',
        'credit_limit',
        'credit_used',
        'payment_terms', // net30, net60, cod, prepaid
        'discount_percentage',
        'tax_exempt',
        'tax_number',
        'business_registration',
        'notes',
        'tags',
        'preferred_payment_method',
        'preferred_delivery_method',
        'is_active',
        'is_blacklisted',
        'blacklist_reason',
        'created_by_id',
        'updated_by_id',
    ];

    protected $casts = [
        'customer_group_id' => 'integer',
        'lifetime_value' => 'decimal:2',
        'purchase_count' => 'integer',
        'average_order_value' => 'decimal:2',
        'credit_limit' => 'decimal:2',
        'credit_used' => 'decimal:2',
        'discount_percentage' => 'decimal:2',
        'tax_exempt' => 'boolean',
        'is_active' => 'boolean',
        'is_blacklisted' => 'boolean',
        'first_purchase_date' => 'datetime',
        'last_purchase_date' => 'datetime',
        'tags' => 'array',
    ];

    /**
     * Get the contact associated with this customer
     */
    public function contact()
    {
        return $this->belongsTo(Contact::class);
    }

    /**
     * Get the customer group
     */
    public function customerGroup()
    {
        return $this->belongsTo(CustomerGroup::class);
    }

    /**
     * Get the company associated with this customer (through contact)
     */
    public function company()
    {
        return $this->hasOneThrough(Company::class, Contact::class, 'id', 'id', 'contact_id', 'company_id');
    }

    /**
     * Get all invoices for this customer
     */
    public function invoices()
    {
        return $this->hasMany(\Modules\Billing\app\Models\Invoice::class, 'customer_id');
    }

    /**
     * Get all field product orders for this customer
     */
    public function fieldProductOrders()
    {
        return $this->hasMany(\Modules\FieldManager\app\Models\FieldProductOrder::class, 'customer_id');
    }

    /**
     * Get the user who created this customer.
     */
    public function createdBy()
    {
        return $this->belongsTo(\App\Models\User::class, 'created_by_id');
    }

    /**
     * Get the user who last updated this customer.
     */
    public function updatedBy()
    {
        return $this->belongsTo(\App\Models\User::class, 'updated_by_id');
    }

    /**
     * Get the user this customer is assigned to (through contact).
     */
    public function assignedTo()
    {
        return $this->hasOneThrough(\App\Models\User::class, Contact::class, 'id', 'id', 'contact_id', 'assigned_to_user_id');
    }

    /**
     * Generate a unique customer code
     *
     * @deprecated Use HasCRMCode trait methods instead
     */
    public static function generateCustomerCode()
    {
        $customer = new self;

        return $customer->forceGenerateCode();
    }

    /**
     * Create or update a customer from a contact after first purchase
     */
    public static function createFromFirstPurchase($contactId, $purchaseData = [])
    {
        $contact = Contact::findOrFail($contactId);

        // Check if customer already exists for this contact
        $customer = self::firstOrNew(['contact_id' => $contactId]);

        if (! $customer->exists) {
            // Get default values from settings
            $settingsService = app(\App\Services\Settings\ModuleSettingsService::class);

            $customer->fill([
                'code' => null, // Will be auto-generated by HasCRMCode trait
                'lifetime_value' => 0,
                'purchase_count' => 0,
                'average_order_value' => 0,
                'credit_limit' => $settingsService->get('CRMCore', 'default_credit_limit', 1000),
                'credit_used' => 0,
                'payment_terms' => $settingsService->get('CRMCore', 'default_payment_terms', 'cod'),
                'discount_percentage' => 0,
                'tax_exempt' => false,
                'is_active' => true,
                'is_blacklisted' => false,
                'tenant_id' => $contact->tenant_id,
                'first_purchase_date' => now(),
                'customer_group_id' => $settingsService->get('CRMCore', 'default_customer_group_id', null),
            ]);
        }

        // Update purchase statistics
        if (isset($purchaseData['amount'])) {
            $customer->lifetime_value += $purchaseData['amount'];
            $customer->purchase_count += 1;
            $customer->average_order_value = $customer->lifetime_value / $customer->purchase_count;
            $customer->last_purchase_date = now();
        }

        $customer->save();

        return $customer;
    }

    /**
     * Update customer statistics after a sale
     */
    public function recordPurchase($amount)
    {
        $this->increment('purchase_count');
        $this->increment('lifetime_value', $amount);

        // Update average order value
        $this->average_order_value = $this->lifetime_value / $this->purchase_count;

        // Update last purchase date
        $this->last_purchase_date = now();

        $this->save();
    }

    /**
     * Check if customer has available credit
     */
    public function hasAvailableCredit($amount = 0)
    {
        return ($this->credit_limit - $this->credit_used) >= $amount;
    }

    /**
     * Get customer type from group or use the stored value
     */
    public function getCustomerTypeAttribute($value)
    {
        // If customer has a group, use the group's code to determine type
        if ($this->customerGroup) {
            // Map group codes to customer types
            $typeMap = [
                'VIP' => 'vip',
                'WHOLESALE' => 'wholesale',
                'CORPORATE' => 'corporate',
                'REGULAR' => 'regular',
            ];

            return $typeMap[strtoupper($this->customerGroup->code)] ?? 'regular';
        }

        // Otherwise return the stored value or default
        return $value ?: 'regular';
    }

    /**
     * Use credit
     */
    public function useCredit($amount)
    {
        if ($this->hasAvailableCredit($amount)) {
            $this->increment('credit_used', $amount);

            return true;
        }

        return false;
    }

    /**
     * Release credit (after payment)
     */
    public function releaseCredit($amount)
    {
        $this->decrement('credit_used', min($amount, $this->credit_used));
    }

    /**
     * Check if customer is eligible for tax exemption
     */
    public function isTaxExempt()
    {
        return $this->tax_exempt;
    }

    /**
     * Check if customer can make purchases
     */
    public function canPurchase()
    {
        return $this->is_active && ! $this->is_blacklisted;
    }

    /**
     * Get customer display name
     */
    public function getDisplayNameAttribute()
    {
        return $this->contact ? $this->contact->getFullNameAttribute() : 'Unknown Customer';
    }

    /**
     * Get customer email
     */
    public function getEmailAttribute()
    {
        return $this->contact ? $this->contact->email_primary : null;
    }

    /**
     * Get customer phone
     */
    public function getPhoneAttribute()
    {
        return $this->contact ? ($this->contact->phone_primary ?: $this->contact->phone_mobile) : null;
    }

    /**
     * Get customer address
     */
    public function getAddressAttribute()
    {
        if (! $this->contact) {
            return null;
        }

        $parts = array_filter([
            $this->contact->address_street,
            $this->contact->address_city,
            $this->contact->address_state,
            $this->contact->address_postal_code,
            $this->contact->address_country,
        ]);

        return implode(', ', $parts);
    }

    /**
     * Scope for active customers
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true)->where('is_blacklisted', false);
    }

    /**
     * Scope for VIP customers
     */
    public function scopeVip($query)
    {
        return $query->where('customer_type', 'vip');
    }

    /**
     * Get available credit
     */
    public function getAvailableCreditAttribute()
    {
        return max(0, $this->credit_limit - $this->credit_used);
    }

    /**
     * Check if customer is B2B (has a company)
     */
    public function isB2B()
    {
        return $this->contact && $this->contact->company_id !== null;
    }

    /**
     * Check if customer is B2C (individual without company)
     */
    public function isB2C()
    {
        return !$this->isB2B();
    }

    /**
     * Get the billing entity for this customer
     * Returns Company for B2B, Contact for B2C
     */
    public function getBillingEntity()
    {
        if ($this->isB2B() && $this->contact->company) {
            return $this->contact->company;
        }
        
        return $this->contact;
    }

    /**
     * Determine customer entity type
     */
    public function resolveEntityType()
    {
        if ($this->isB2B()) {
            return 'company';
        }
        
        return 'individual';
    }
    
    /**
     * Get customer segment based on purchase history
     */
    public function getSegment()
    {
        if ($this->lifetime_value >= 100000) {
            return 'enterprise';
        } elseif ($this->lifetime_value >= 50000) {
            return 'premium';
        } elseif ($this->lifetime_value >= 10000) {
            return 'standard';
        }
        
        return 'basic';
    }
    
    /**
     * Check if customer has made a purchase
     */
    public function hasPurchased()
    {
        return $this->purchase_count > 0;
    }
    
    /**
     * Check if customer is new (first purchase within 30 days)
     */
    public function isNew()
    {
        return $this->first_purchase_date && 
               $this->first_purchase_date->diffInDays(now()) <= 30;
    }
    
    /**
     * Check if customer is inactive (no purchase in last 90 days)
     */
    public function isInactive()
    {
        return $this->last_purchase_date && 
               $this->last_purchase_date->diffInDays(now()) > 90;
    }
    
    /**
     * Get customer's primary contact person
     */
    public function getPrimaryContact()
    {
        return $this->contact;
    }
    
    /**
     * Get customer's company if B2B
     */
    public function getCompany()
    {
        if ($this->isB2B()) {
            return $this->contact->company;
        }
        
        return null;
    }
    
    /**
     * Get customer classification
     */
    public function getClassification()
    {
        if ($this->customerGroup) {
            return $this->customerGroup->name;
        }
        
        // Default classification based on type and segment
        $type = $this->isB2B() ? 'B2B' : 'B2C';
        $segment = $this->getSegment();
        
        return "{$type} - {$segment}";
    }
    
    /**
     * Get customer risk level based on credit and payment history
     */
    public function getRiskLevel()
    {
        // Check if blacklisted
        if ($this->is_blacklisted) {
            return 'high';
        }
        
        // Check credit utilization
        $creditUtilization = $this->credit_limit > 0 
            ? ($this->credit_used / $this->credit_limit) * 100 
            : 0;
            
        if ($creditUtilization > 80) {
            return 'medium';
        }
        
        // Check if inactive
        if ($this->isInactive()) {
            return 'medium';
        }
        
        return 'low';
    }
}
